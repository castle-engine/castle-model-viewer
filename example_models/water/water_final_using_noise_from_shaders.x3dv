#X3D V3.2 utf8
PROFILE Interchange

# Plane with water.
# - Uses RenderedTexture, ViewpointMirror and MIRROR-PLANE texture mapping
#   for reflections.
#   See https://castle-engine.io/x3d_extensions_mirror_plane.php
# - Uses shaders for a procedurally-generated seamless bump map.
#
# To add a water to your game, you can use this file:
#
# - Make sure to copy this file, along with the shaders/ subdirectory.
#
# - Probably remove the Inline node that includes water_simple_scene.x3d here.
#   In real game, you should add additional geometry using CGE component
#   TCastleScene. You can compose world from multiple TCastleScene instances.
#
# - Probably remove the "bindable" nodes in this file
#   (Viewpoint, NavigationInfo, Fog, Background).
#   In real game, you like setup camera/fog/background using CGE components
#   TCastleCamera, TCastleFog, TCastleBackground, not using X3D nodes.
#
# - You can adjust water parameters:
#   - You can adjust WaterTransform translation/scale/rotation,
#     to make the plane appear where you want it.
#   - You can adjust some constants in shaders/animate_normals.fs:
#     wave_speed, wave_size, wave_calmness, wave_perturb_reflection.

# ----------------------------------------------------------------------------
# Bindable nodes

# Generated by castle-model-viewer.
# Use castle-model-viewer "Clipboard -> Print Current Camera..." to generate X3D code like below.
# Camera settings "encoded" in the X3D declaration below :
#   position -0.11 1.72 -7.91
#   direction 0.15 0.00 0.99
#   up 0.00 1.00 0.00
#   gravityUp 0.00 1.00 0.00
Viewpoint {
  position -0.11271689087152481 1.7243608236312866 -7.9072012901306152
  orientation 0.00017233505786862224 -1 -0.000012710928785963915 2.9945995807647705
}

NavigationInfo {
  headlight FALSE # it's bright enough without the headlight already
  type [ "WALK", "ANY" ]
  speed 10
}

Background {
  backUrl "../skies/foggy_sky_back.png"
  bottomUrl "../skies/foggy_sky_bottom.png"
  frontUrl "../skies/foggy_sky_front.png"
  leftUrl "../skies/foggy_sky_left.png"
  rightUrl "../skies/foggy_sky_right.png"
  topUrl "../skies/foggy_sky_top.png"
}

# ----------------------------------------------------------------------------
# Inline the main geometry

Inline {
  url "water_simple_scene.x3d"
}

# ----------------------------------------------------------------------------
# Water surface

Collision {
  enabled FALSE
  children DEF WaterTransform Transform {
    translation -10 -0.1 -10 # move and scale it as you wish
    scale 20 20 20

    children Shape {
      appearance Appearance {
        material PhysicalMaterial {
          transparency 0.25
          baseColor 0.6 0.6 1.0
          baseTexture RenderedTexture {
            dimensions [ 2048 2048 3 ]
            viewpoint ViewpointMirror { }
            repeatS FALSE
            repeatT FALSE
            update "ALWAYS"
          }
        }

        # Calculate animated normal vectors using GLSL
        effects DEF EffectAnimatedNormals Effect {
          # enabled FALSE
          language "GLSL"
          inputOnly SFTime time
          parts [
            EffectPart {
              type "VERTEX"
              url "shaders/animate_normals.vs"
            }
            EffectPart {
              type "FRAGMENT"
              url "shaders/animate_normals.fs"
            }
            EffectPart {
              type "FRAGMENT"
              url "shaders/noise3Dgrad.glsl"
            }
          ]
        }
      }
      geometry IndexedFaceSet {
        coord Coordinate {
          point [ 0 0 0, 0 0 1, 1 0 1, 1 0 0, ]
        }
        coordIndex [ 0 1 2 3 ]
        texCoord MultiGeneratedTextureCoordinate {
          texCoord [
            # generate texture coordinates
            # that match the texture produced by RenderedTexture and ViewpointMirror
            # (in diffuseTexture)
            TextureCoordinateGenerator {
              mode "MIRROR-PLANE"
            }
          ]
        }
      }
    }
  }
}

# MyTimeSensor provides values for GLSL "time" uniform.
DEF MyTimeSensor TimeSensor {
  loop TRUE
}
ROUTE MyTimeSensor.elapsedTime TO EffectAnimatedNormals.time

# Without MyProximitySensor, MyTimeSensor.elapsedTime output
# values would be huge, as TimeSensor "starts" at Unix epoch.
# Such huge floats would make GLSL shader computations useless (the results
# of the shaders would look still).
# So we we use MyProximitySensor to activate MyTimeSensor on scene enter.
DEF MyProximitySensor ProximitySensor {
  size 10000000 10000000 10000000 # huge size, to always be activated
}
ROUTE MyProximitySensor.enterTime TO MyTimeSensor.startTime
